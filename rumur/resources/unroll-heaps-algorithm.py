#!/usr/bin/env python3

'''
generator for unrolled versions of Heap's Algorithm

Tracking successive scalarset permutations during verification is done using the
functions permutation_to_index() and index_to_permutation() in header.c, that
derive a two way mapping between numbers and permutations. The implementation of
these two functions follows Heap's Algorithm for iterating over permutations.
However, this was found to be quite expensive when initially implemented (~18%
performance overhead during verification).

Taking advantage of the fact that scalarsets of size >5 are rarely used in real
world models, we can specialise the mapping functions by statically unrolling
Heap's Algorithm to simply linearly iterate over known permutations. The
following script can be used to generate C versions of such specialisations.

This is not called during compilation of Rumur, but was rather run once, and its
output copied into header.c.
'''

import argparse
import sys

def heap(count: int):
  '''
  Heap's Algorithm. This is intended to exactly mimic the implementation logic
  in header.c.
  '''

  index = 0
  stack = [0] * count
  permutation = list(range(count))

  yield index, tuple(permutation)

  i = 0
  while i < count:
    if stack[i] < i:
      index += 1
      if i % 2 == 0:
        permutation[0], permutation[i] = permutation[i], permutation[0]
      else:
        permutation[stack[i]], permutation[i] \
          = permutation[i], permutation[stack[i]]
      yield index, tuple(permutation)
      stack[i] += 1
      i = 0
    else:
      stack[i] = 0
      i += 1

def main(args: [str]) -> int:

  # parse command line arguments
  parser = argparse.ArgumentParser(
    description='generator for an unrolled Heap\'s Algorithm')
  parser.add_argument('limit', type=int, help='maximum size of array to handle')
  options = parser.parse_args(args[1:])

  # shortcut for printing
  def w(s: str): sys.stdout.write(s)

  # generate permutation -> index function
  w('/* unrolled version of permutation_to_index() generated by\n'
    ' * unroll-heaps-algorithm.py\n'
    ' */\n'
    'static size_t permutation_to_index_unrolled(const size_t *NONNULL '
      'permutation,\n'
    '    size_t count) {\n'
    '\n'
   f'  ASSERT(count <= {options.limit});\n'
    '\n'
    '  switch (count) {\n'
    '\n')
  for limit in range(2, options.limit + 1):
    w(f'    case {limit}:\n')
    for index, permutation in heap(limit):
      w(f'      if ({" && ".join(f"permutation[{i}] == {j}" for i, j in enumerate(permutation))}) {{\n'
        f'        return {index};\n'
         '      }\n')
    w('      break;\n'
      '\n')
  w('  }\n'
    '\n'
    '  ASSERT(!"invalid call to permutation_to_index_unrolled()");\n'
    '}\n'
    '\n')

  # generate index -> permutation function
  w('/* unrolled version of index_to_permutation() generated by\n'
    ' * unroll-heaps-algorithm.py\n'
    ' */\n'
    'static void index_to_permutation_unrolled(size_t index,\n'
    '    size_t *NONNULL permutation, size_t count) {\n'
    '\n'
   f'  ASSERT(count <= {options.limit});\n'
    '\n'
    '  switch (count) {\n'
    '\n')
  for limit in range(2, options.limit + 1):
    w(f'    case {limit}:\n'
       '      switch (index) {\n')
    for index, permutation in heap(limit):
      w(f'        case {index}:\n')
      for i, p in enumerate(permutation):
        w(f'            permutation[{i}] = {p};\n')
      w('            return;\n'
        '\n')
    w('      }\n'
      '      break;\n'
      '\n')
  w('  }\n'
    '\n'
    '  ASSERT(!"invalid call to index_to_permutation_unrolled()");\n'
    '}\n'
    '\n')

  return 0

if __name__ == '__main__':
  sys.exit(main(sys.argv))
