.TH RUMUR 1
.SH NAME
rumur \- Yet another explicit state model checker
.SH SYNOPSIS
.B \fBrumur\fR \fBoptions\fR \fB--output\fR \fIFILE\fR [\fIFILE\fR]
.SH DESCRIPTION
Rumur is a reimplementation of the model checker CMurphi with improved
performance and a slightly different feature set.
.SH OPTIONS
\fB--colour\fR [\fBauto\fR | \fBoff\fR | \fBon\fR]
.RS
Enable or disable the use of ANSI colour codes in the verifier's output. The
default is \fBauto\fR, to auto-detect based on whether the verifier's stdout is
a TTY.
.RE
.PP
\fB--counterexample-trace\fR [\fBdiff\fR | \fBfull\fR | \fBoff\fR]
.RS
Set how counterexample traces are printed when an error is found during
checking. \fBdiff\fR, the default, prints each state showing only the
differences from the previous state. \fBfull\fR shows the entire contents of
each state. \fBoff\fR disables counterexample trace printing altogether.
.RE
.PP
\fB--deadlock-detection\fR [\fBoff\fR | \fBstuck\fR | \fBstuttering\fR]
.RS
Enable or disable deadlock detection. Rumur has the ability to generate a
verifier that notices when there is no valid transition out of a state and raise
an error in this scenario. The possible modes for this check are:
.RS
.IP \[bu] 2
\fBoff\fR No deadlock checks are performed.
.IP \[bu]
\fBstuck\fR A deadlock is reached when arriving at a state from which there
are no enabled transitions, and an error is signaled in this case.
.IP \[bu]
\fBstuttering\fR A deadlock is reached in the same circumstances as for the
\fBstuck\fR option or additionally if there are enabled transitions but these
all result in an identical state. For CMurphi users, this is the scenario that
CMurphi considers to be a deadlock.
.RE
.PP
This defaults to \fBstuttering\fR. However, whether such a deadlock actually
represents a problem depends on the properties of the system you are modelling.
Hence you may want to change deadlock detection.
.RE
.PP
\fB--debug\fR or \fB-d\fR
.RS
Enable debugging options in the generated verifier. This includes enabling
runtime assertions. This will also output debugging messages while generating
the verifier.
.RE
.PP
\fB--help\fR
.RS
Display this information.
.RE
.PP
\fB--max-errors\fR \fICOUNT\fR
.RS
Number of errors the verifier should report before considering them fatal. By
default this is \fI1\fR, that is exit as soon as an error is encountered.
However, you may wish to set a higher value to get multiple error traces from a
single run.
.RE
.PP
\fB--monopolise\fR
.RS
Assume that the machine the generated verifier will run on is the current host
and that it will be the only process running. This flag causes the verifier to
upfront allocate a seen set that will eventually occupy all of memory. That is,
it is the same as passing \fB--set-expand-threshold 100\fR and
\fB--set-capacity\fR with the total amount of physical memory available on the
current machine.
.RE
.PP
\fB--output\fR \fIFILE\fR or \fB-o\fR \fIFILE\fR
.RS
Set path to write the generated C verifier's code to.
.RE
.PP
\fB--output-format\fR [\fBmachine-readable\fR | \fBhuman-readable\fR]
.RS
Change the format in which the verifier displays its output. By default, it uses
\fBhuman-readable\fR which results in progress output and then a final summary
of the result. Using \fBmachine-readable\fR generates output in an XML format
suitable for consumption by a following tool in an I/O pipeline.
.RE
.PP
\fB--quiet\fR or \fB-q\fR
.RS
Don't output any messages while generating the verifier.
.RE
.PP
\fB--sandbox\fR [\fBon\fR | \fBoff\fR]
.RS
Control whether the generated verifier uses your operating system's sandboxing
facilities to limit its own operations. The verifier does not intentionally
perform any malicious or dangerous operations, but at the end of the day it is a
generated program that you are going to execute. To safeguard against a bug in
the code generator, it is recommended to constrain the operations the verifier is
allowed to perform if you are using a model you did not write yourself. By
default this is \fBoff\fR.
.RE
.PP
\fB--set-capacity\fR \fISIZE\fR or \fB-s\fR \fISIZE\fR
.RS
The size of the initial set to allocate for storing seen states. This is given
in bytes and is interpreted to mean the desired size of the set when it is
completely full. That is, the initial allocation performed will be for a number
of "state slots" that, when all occupied, will consume this much memory. Default
value for this 8MB.
.RE
.PP
\fB--set-expand-threshold\fR \fIPERCENT\fR or \fB-e\fR \fIPERCENT\fR
.RS
Expand the state set when its occupancy exceeds this percentage. Default is
\fI65\fR, valid values are \fI1\fR - \fI100\fR. Setting a value of 100 will
result in the set only expanding when completely full. This may sound ideal, but
will actually result in a much longer runtime.
.RE
.PP
\fB--symmetry-reduction\fR [\fBoff\fR | \fBheuristic\fR | \fBexhaustive\fR ]
.RS
Enable or disable symmetry reduction. Symmetry reduction is an optimisation that
decreases the state space that must be searched by deriving a canonical
representation of each state. While two states may not be directly equal, if
their canonical representations are the same only one of them need be expanded.
To take advantage of this optimisation you must be using named \fBscalarset\fR
types. The available options are:
.RS
.IP \[bu] 2
\fBoff\fR Do not use symmetry reduction. All scalarsets will be treated as if
they were range types.
.IP \[bu]
\fBheuristic\fR Use a symmetry reduction algorithm based on sorting the state
data. This is not guaranteed to find a single, canonical representation for each
equivalent state, but it is fast and performs reasonably well empirically. Using
this option, you may explore more states than you need to, with the advantage
that you will process each individual state much faster than with
\fBexhaustive\fR. This is the default.
.IP \[bu]
\fBexhaustive\fR Use a symmetry reduction algorithm based on exhaustive
permutation of the state data. This is guaranteed to find a single, canonical
representation for each equivalent state, but is typically very slow. Use this
if you want to minimise memory usage at the expense of runtime.
.RE
.RE
.PP
\fB--threads\fR \fICOUNT\fR or \fB-t\fR \fICOUNT\fR
.RS
Specify the number of threads the verifier should use. If you do not specify this
parameter or pass \fI0\fR, the number of threads will be chosen based on the
available hardware threads on the platform on which you generate the model.
.RE
.PP
\fB--trace\fR \fICATEGORY\fR
.RS
Enable tracing of specific events while checking. This option is for debugging
Rumur itself, and lets you generate a verifier that writes events to stderr.
Available event categories are:
.RS
.IP \[bu] 2
\fIhandle_reads\fR Reads from variable handles
.IP \[bu]
\fIhandle_writes\fR Writes to variable handles
.IP \[bu]
\fIqueue\fR Events relating to the pending state queue
.IP \[bu]
\fIset\fR Events relating to the seen state set
.IP \[bu]
\fIsymmetry_reduction\fR Events related to the symmetry reduction optimisation
.IP \[bu]
\fIall\fR Enable all of the above
.RE
.PP
More than one of these can be enabled at once by passing the \fB--trace\fR
argument multiple times. Note that enabling tracing will significantly slow the
verifier and is only intended for debugging purposes.
.RE
.PP
\fB--verbose\fR or \fB-v\fR
.RS
Output informational messages while generating the verifier.
.RE
.PP
\fB--version\fR
.RS
Display version information and exit.
.RE
.SH AUTHOR
All comments, questions and complaints should be directed to Matthew Fernandez
<matthew.fernandez@gmail.com>.
.SH LICENSE
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org>
